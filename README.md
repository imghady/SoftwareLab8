# SoftwareLab8
# آزمایش شماره ۸ آزمایشگاه مهندسی نرم‌افزار(الگوهای طراحی)
## بخش اول - گزارش پیاده‌سازی
## بخش دوم - پاسخ به پرسش‌ها
۱- در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.

الگوهای ایجادی (Creational Patterns)
این دسته از الگوها به فرآیند ایجاد اشیاء می‌پردازند و سعی در افزایش انعطاف‌پذیری و استفاده مجدد از کد در هنگام ساخت اشیاء دارند. آن‌ها چگونگی ایجاد، ترکیب و نمایش اشیاء را از سیستم جدا می‌کنند.

الگوهای ساختاری (Structural Patterns)
این الگوها با چگونگی ترکیب کلاس‌ها و اشیاء برای تشکیل ساختارهای بزرگتر سروکار دارند و در عین حال این ساختارها را انعطاف‌پذیر و کارآمد نگه می‌دارند. تمرکز آن‌ها بر ساده‌سازی ساختار و شناسایی روابط بین موجودیت‌ها است.

الگوهای رفتاری (Behavioral Patterns)
این دسته از الگوها به الگوریتم‌ها و تخصیص مسئولیت‌ها بین اشیاء می‌پردازند و الگوهای ارتباطی رایج بین اشیاء را شناسایی و پیاده‌سازی می‌کنند. آن‌ها انعطاف‌پذیری در نحوه همکاری و ارتباط اشیاء با یکدیگر را افزایش می‌دهند.


۲- الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟

۳- با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.

۴- تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).

اصل تک مسئولیتی (Single Responsibility Principle - SRP): عدم تحقق
کلاس Singleton علاوه بر مسئولیت اصلی خود (که بسته به کاربرد متفاوت است)، مسئولیت کنترل ایجاد و دسترسی به تنها نمونه خود را نیز بر عهده دارد. این دو مسئولیت مجزا هستند و طبق اصل SRP، باید در کلاس‌های جداگانه‌ای قرار گیرند.

اصل باز/بسته (Open/Closed Principle - OCP): عدم تحقق
کلاس‌های Singleton معمولاً برای توسعه باز نیستند، زیرا سازنده آن‌ها خصوصی است و امکان ارث‌بری و گسترش رفتار آن‌ها به سادگی وجود ندارد. برای تغییر رفتار، اغلب نیاز به تغییر خود کلاس Singleton است که ناقض اصل بسته بودن برای تغییر است.

اصل جایگزینی لیسکوف (Liskov Substitution Principle - LSP): عدم تحقق (در اکثر پیاده‌سازی‌های رایج)
از آنجایی که سازنده Singleton خصوصی است و امکان ارث‌بری مستقیم و ایجاد زیرکلاس‌های قابل جایگزین که رفتار اصلی را حفظ کنند وجود ندارد، این اصل معمولاً نقض می‌شود. اگرچه می‌توان Singleton را با استفاده از اینترفیس پیاده‌سازی کرد تا حدی LSP رعایت شود، اما ذات کنترل نمونه‌سازی توسط خود کلاس، مشکل‌ساز است.

اصل جداسازی اینترفیس (Interface Segregation Principle - ISP): می‌تواند تحقق یابد
الگوی Singleton به خودی خود مستقیماً با این اصل در تضاد نیست. اگر Singleton یک اینترفیس "چاق" (fat interface) را پیاده‌سازی کند، آنگاه ISP نقض می‌شود. اما اگر اینترفیسی که Singleton پیاده‌سازی می‌کند (در صورت وجود) کوچک و متمرکز باشد، این اصل رعایت می‌شود.

اصل وارونگی وابستگی (Dependency Inversion Principle - DIP): عدم تحقق
کلاس‌هایی که از Singleton استفاده می‌کنند، مستقیماً به کلاس بتنی (concrete) آن وابسته می‌شوند، نه به یک انتزاع (abstraction). این وابستگی مستقیم به یک پیاده‌سازی خاص، انعطاف‌پذیری را کاهش داده و تست‌پذیری را دشوار می‌کند و بنابراین اصل وارونگی وابستگی را نقض می‌کند.
