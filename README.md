# آزمایش شماره ۸ آزمایشگاه مهندسی نرم‌افزار (الگوهای طراحی)

## بخش اول - گزارش پیاده‌سازی

## سیستم اعلام وضعیت بسته‌های پستی کشتی

این پروژه یک برنامه ساده جاوا برای شبیه‌سازی سیستم اعلام وضعیت بسته‌های پستی است که با کشتی جابجا می‌شوند.
هدف اصلی این پروژه، نمایش پیاده‌سازی الگوهای طراحی Strategy و State است.
این برنامه برای یک بسته در هر لحظه اجرا می‌شود و وضعیت و نحوه‌ی ارسال آن قابل تغییر در زمان اجرا است.

## الگوهای طراحی استفاده شده

### ۱. الگوی طراحی Strategy (استراتژی)

* هدف: این الگو به شما اجازه می‌دهد تا خانواده‌ای از الگوریتم‌ها را تعریف کرده، هر کدام را در یک کلاس جداگانه کپسوله کنید و آن‌ها را قابل تعویض نمایید. در این پروژه، برای محاسبه هزینه ارسال بسته بر اساس روش‌های مختلف (Standard و Express) از این الگو استفاده شده است.

* نحوه پیاده‌سازی:
  * یک رابط به نام ShippingStrategy تعریف شده است که متد calculateCost(double weight) و getSpeedDescription() را مشخص می‌کند.
  * دو کلاس StandardShippingStrategy و ExpressShippingStrategy این رابط را پیاده‌سازی می‌کنند و هرکدام منطق محاسبه هزینه و توضیحات سرعت خاص خود را دارند.
    * Standard: هزینه = وزن * ۲.۵
    * Express: هزینه = وزن * ۳.۵
  * کلاس Package (که به عنوان Context عمل می‌کند) یک ارجاع به ShippingStrategy دارد. متد setShippingStrategy اجازه تغییر استراتژی ارسال را در زمان اجرا می‌دهد و متد getCurrentCost هزینه را بر اساس استراتژی فعلی محاسبه می‌کند.

* تحقق الگو:
    کلاس Package می‌تواند در زمان اجرا بین StandardShippingStrategy و ExpressShippingStrategy سوئیچ کند. این کار باعث می‌شود الگوریتم محاسبه هزینه بدون تغییر در کد کلاس Package یا کلاس‌های مشتری تغییر کند. انتخاب الگوریتم از کلاینتی که از آن استفاده می‌کند (در اینجا Package) جدا شده است. هر زمان که روش ارسال تغییر می‌کند، هزینه بسته فوراً بر اساس روش جدید محاسبه می‌شود، مطابق با این نیازمندی که "قیمت تمام شده نیز بر اساس آخرین روش ارسال بسته باید باشد".

### ۲. الگوی طراحی State (وضعیت)

* هدف: این الگو به یک شیء اجازه می‌دهد تا رفتار خود را زمانی که وضعیت داخلی‌اش تغییر می‌کند، تغییر دهد. شیء به نظر می‌رسد که کلاس خود را تغییر داده است. در این پروژه، برای مدیریت وضعیت‌های مختلف بسته پستی (in-transit و delivered) از این الگو استفاده شده است.

* نحوه پیاده‌سازی:
  * یک رابط به نام PackageState تعریف شده است که متدهای onEnterState(Package pkgContext)`،`isDelivered() و getStatusDescription() را مشخص می‌کند.
  * دو کلاس InTransitState و DeliveredState این رابط را پیاده‌سازی می‌کنند.
    * InTransitState: نشان‌دهنده وضعیت "در حال ارسال" است. با ورود به این وضعیت، پیامی مبنی بر ارسال چاپ می‌شود. isDelivered() مقدار false برمی‌گرداند.
    * DeliveredState: نشان‌دهنده وضعیت "رسیده به مقصد" است. با ورود به این وضعیت، پیامی مبنی بر رسیدن بسته چاپ می‌شود و isDelivered() مقدار true برمی‌گرداند که باعث اتمام برنامه می‌شود.
  * کلاس Package (که به عنوان Context عمل می‌کند) یک ارجاع به PackageState دارد. متد setPackageState اجازه تغییر وضعیت بسته را می‌دهد و هنگام تغییر وضعیت، متد onEnterState وضعیت جدید فراخوانی می‌شود تا پیام مناسب چاپ شود.

* تحقق الگو:
    رفتار شیء Package (مانند پیام‌هایی که چاپ می‌شوند یا شرط پایان حلقه اصلی برنامه) بر اساس PackageState فعلی آن (InTransitState یا DeliveredState) تغییر می‌کند. هر وضعیت، منطق و رفتار خاص خود را کپسوله می‌کند. با تغییر وضعیت بسته، پیام مربوطه چاپ شده و در صورت رسیدن به مقصد، برنامه خاتمه می‌یابد.

## رویکرد ایجاد آزمون‌رانه (TDD)

در توسعه این پروژه، از رویکرد TDD پیروی شده است (یا حداقل تلاش شده تا اصول آن رعایت شود). این به این معناست که:

۱. نوشتن تست ابتدا: برای هر قابلیت جدید یا هر جزء از سیستم (مانند یک استراتژی محاسبه هزینه یا یک وضعیت بسته)، ابتدا یک یا چند تست نوشته شده است که رفتار مورد انتظار را تعریف می‌کند. این تست‌ها در ابتدا باید شکست بخورند (چون کدی برای پاس کردن آن‌ها وجود ندارد).

۲. نوشتن حداقل کد برای پاس کردن تست: سپس، حداقل میزان کد لازم برای پاس کردن آن تست‌ها نوشته شده است.

۳. بازآرایی کد (Refactor): پس از پاس شدن تست‌ها، کد نوشته شده بررسی و در صورت نیاز بازآرایی (refactor) شده است تا خوانایی، کارایی و طراحی آن بهبود یابد، در حالی که اطمینان حاصل می‌شود که تمام تست‌ها همچنان پاس می‌شوند.

این رویکرد به اطمینان از صحت عملکرد هر جزء و همچنین کاهش خطاها در طول توسعه کمک می‌کند.

## نحوه اجرای برنامه

۱.  ابتدا کد را کامپایل می‌کنیم:

    javac -d src/main/java/org/example/*.java

۲.  اجرا: کلاس اصلی برنامه Main.java است:

    java com.example.Main
    
۳.  ورودی: برنامه از شما وزن محصول، روش ارسال و وضعیت محصول را در یک حلقه دریافت می‌کند تا زمانی که بسته به مقصد برسد.

## بخش دوم - پاسخ به پرسش‌ها

۱- در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.

الگوهای ایجادی (Creational Patterns)
این دسته از الگوها به فرآیند ایجاد اشیاء می‌پردازند و سعی در افزایش انعطاف‌پذیری و استفاده مجدد از کد در هنگام ساخت اشیاء دارند. آن‌ها چگونگی ایجاد، ترکیب و نمایش اشیاء را از سیستم جدا می‌کنند.

الگوهای ساختاری (Structural Patterns)
این الگوها با چگونگی ترکیب کلاس‌ها و اشیاء برای تشکیل ساختارهای بزرگتر سروکار دارند و در عین حال این ساختارها را انعطاف‌پذیر و کارآمد نگه می‌دارند. تمرکز آن‌ها بر ساده‌سازی ساختار و شناسایی روابط بین موجودیت‌ها است.

الگوهای رفتاری (Behavioral Patterns)
این دسته از الگوها به الگوریتم‌ها و تخصیص مسئولیت‌ها بین اشیاء می‌پردازند و الگوهای ارتباطی رایج بین اشیاء را شناسایی و پیاده‌سازی می‌کنند. آن‌ها انعطاف‌پذیری در نحوه همکاری و ارتباط اشیاء با یکدیگر را افزایش می‌دهند.

۲- الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟

الگوهای طراحی Strategy و State که در آزمایش پیاده‌سازی سیستم بسته‌های پستی استفاده شدند، هر دو جزو دسته الگوهای رفتاری (Behavioral Patterns) هستند.

---

### الگوهای رفتاری

این دسته از الگوها به نحوه تعامل و تخصیص مسئولیت‌ها بین اشیاء می‌پردازند. آن‌ها الگوهای ارتباطی رایج بین اشیاء را شناسایی و پیاده‌سازی می‌کنند و انعطاف‌پذیری را در نحوه همکاری اشیاء با یکدیگر افزایش می‌دهند.

الگوی Strategy (استراتژی): یک الگوی رفتاری است زیرا به شما امکان می‌دهد خانواده‌ای از الگوریتم‌ها را تعریف کرده، هر کدام را کپسوله کنید و آن‌ها را قابل تعویض نمایید. این الگو بر نحوه انجام یک عمل (رفتار) توسط یک شیء (Context) تمرکز دارد و اجازه می‌دهد این رفتار در زمان اجرا تغییر کند.
الگوی State (وضعیت): نیز یک الگوی رفتاری است زیرا به یک شیء اجازه می‌دهد رفتار خود را زمانی که وضعیت داخلی‌اش تغییر می‌کند، تغییر دهد. این الگو چگونگی رفتار یک شیء را بر اساس وضعیت فعلی‌اش مدیریت می‌کند.

۳- با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.

برای ایجاد و مدیریت تنها یک نمونه از بسته پستی در طول اجرای برنامه، الگوی طراحی Singleton (یگانه) مناسب‌ترین گزینه است.

---
در ادامه به توضیح این قشیه می‌پردازیم که چرا سینگلتون بهترین گزینه است:

تضمین یگانگی: این الگو اطمینان می‌دهد که تنها یک شیء (instance) از کلاس `Package` ساخته می‌شود، که دقیقاً با شرط "محصراً یک بسته داریم" هماهنگ است.
دسترسی سراسری: یک نقطه دسترسی عمومی و کنترل‌شده به این نمونه واحد فراهم می‌کند.

---

### نحوه پیاده‌سازی و تحقق

1. سازنده (Constructor) خصوصی:
    * سازنده کلاس `Package` به صورت `private` تعریف می‌شود (مثلاً `private Package(double weight)`). این کار از ایجاد نمونه با `new` از خارج کلاس جلوگیری می‌کند.

2. متغیر استاتیک نمونه:
    * یک متغیر استاتیک خصوصی در کلاس `Package` برای نگهداری نمونه واحد تعریف می‌شود: `private static Package instance;`.

3. متد `getInstance` عمومی و استاتیک:
     یک متد `public static Package getInstance(double weight)` ایجاد می‌شود.
    منطق داخلی:
        *اگر `instance` هنوز `null` باشد (یعنی اولین فراخوانی)، یک نمونه جدید `Package` با وزن داده شده ایجاد و در `instance` ذخیره می‌شود.
        * در غیر این صورت (فراخوانی‌های بعدی)، همان `instance` قبلی برگردانده می‌شود. وزن ورودی در این حالت معمولاً نادیده گرفته می‌شود یا برای اعتبار سنجی استفاده می‌شود (چون بسته قبلاً با یک وزن مشخص ایجاد شده).
    * برای جلوگیری از مشکلات در محیط‌های چندنخی، این متد می‌تواند `synchronized` تعریف شود.

4. فراخوانی از `Main`:
    * در کلاس `Main`، به جای `postalPackage = new Package(weight);` از `postalPackage = Package.getInstance(weight);` برای دریافت یا ایجاد نمونه بسته استفاده می‌شود.

5. پیام وضعیت اولیه:
    * پیام اولیه "in-transit" که قبلاً هنگام ساخت شیء چاپ می‌شد، اکنون باید پس از اولین فراخوانی `getInstance` و ایجاد شیء (مثلاً با فراخوانی یک متد کمکی مانند `initializeStateMessage()` روی نمونه برگردانده شده یا مستقیماً درون `getInstance` پس از ایجاد) نمایش داده شود.

---
با این روش، کلاس `Package` کنترل کاملی بر تعداد نمونه‌های خود (که فقط یکی است) خواهد داشت و سایر بخش‌های برنامه از طریق متد `getInstance` به آن دسترسی پیدا می‌کنند. سایر عملکردها و الگوهای (Strategy و State) که قبلاً برای کلاس `Package` تعریف شده بودند، درون همین نمونه Singleton مدیریت می‌شوند.

۴- تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).

اصل تک مسئولیتی (Single Responsibility Principle - SRP): عدم تحقق
کلاس Singleton علاوه بر مسئولیت اصلی خود (که بسته به کاربرد متفاوت است)، مسئولیت کنترل ایجاد و دسترسی به تنها نمونه خود را نیز بر عهده دارد. این دو مسئولیت مجزا هستند و طبق اصل SRP، باید در کلاس‌های جداگانه‌ای قرار گیرند.

اصل باز/بسته (Open/Closed Principle - OCP): عدم تحقق
کلاس‌های Singleton معمولاً برای توسعه باز نیستند، زیرا سازنده آن‌ها خصوصی است و امکان ارث‌بری و گسترش رفتار آن‌ها به سادگی وجود ندارد. برای تغییر رفتار، اغلب نیاز به تغییر خود کلاس Singleton است که ناقض اصل بسته بودن برای تغییر است.

اصل جایگزینی لیسکوف (Liskov Substitution Principle - LSP): عدم تحقق (در اکثر پیاده‌سازی‌های رایج)
از آنجایی که سازنده Singleton خصوصی است و امکان ارث‌بری مستقیم و ایجاد زیرکلاس‌های قابل جایگزین که رفتار اصلی را حفظ کنند وجود ندارد، این اصل معمولاً نقض می‌شود. اگرچه می‌توان Singleton را با استفاده از اینترفیس پیاده‌سازی کرد تا حدی LSP رعایت شود، اما ذات کنترل نمونه‌سازی توسط خود کلاس، مشکل‌ساز است.

اصل جداسازی اینترفیس (Interface Segregation Principle - ISP): می‌تواند تحقق یابد
الگوی Singleton به خودی خود مستقیماً با این اصل در تضاد نیست. اگر Singleton یک اینترفیس "چاق" (fat interface) را پیاده‌سازی کند، آنگاه ISP نقض می‌شود. اما اگر اینترفیسی که Singleton پیاده‌سازی می‌کند (در صورت وجود) کوچک و متمرکز باشد، این اصل رعایت می‌شود.

اصل وارونگی وابستگی (Dependency Inversion Principle - DIP): عدم تحقق
کلاس‌هایی که از Singleton استفاده می‌کنند، مستقیماً به کلاس بتنی (concrete) آن وابسته می‌شوند، نه به یک انتزاع (abstraction). این وابستگی مستقیم به یک پیاده‌سازی خاص، انعطاف‌پذیری را کاهش داده و تست‌پذیری را دشوار می‌کند و بنابراین اصل وارونگی وابستگی را نقض می‌کند.
