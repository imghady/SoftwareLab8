# SoftwareLab8
# آزمایش شماره ۸ آزمایشگاه مهندسی نرم‌افزار(الگوهای طراحی)
## بخش اول - گزارش پیاده‌سازی
## بخش دوم - پاسخ به پرسش‌ها
۱- در کتاب GoF سه دسته الگوی طراحی معرفی شده است. آن‌ها را نام ببرید و در مورد هر دسته در حد دو خط توضیح دهید.

الگوهای ایجادی (Creational Patterns)
این دسته از الگوها به فرآیند ایجاد اشیاء می‌پردازند و سعی در افزایش انعطاف‌پذیری و استفاده مجدد از کد در هنگام ساخت اشیاء دارند. آن‌ها چگونگی ایجاد، ترکیب و نمایش اشیاء را از سیستم جدا می‌کنند.

الگوهای ساختاری (Structural Patterns)
این الگوها با چگونگی ترکیب کلاس‌ها و اشیاء برای تشکیل ساختارهای بزرگتر سروکار دارند و در عین حال این ساختارها را انعطاف‌پذیر و کارآمد نگه می‌دارند. تمرکز آن‌ها بر ساده‌سازی ساختار و شناسایی روابط بین موجودیت‌ها است.

الگوهای رفتاری (Behavioral Patterns)
این دسته از الگوها به الگوریتم‌ها و تخصیص مسئولیت‌ها بین اشیاء می‌پردازند و الگوهای ارتباطی رایج بین اشیاء را شناسایی و پیاده‌سازی می‌کنند. آن‌ها انعطاف‌پذیری در نحوه همکاری و ارتباط اشیاء با یکدیگر را افزایش می‌دهند.


۲- الگوهای استفاده شده در این آزمایش جزو کدام دسته هستند؟


الگوهای طراحی Strategy و State که در آزمایش پیاده‌سازی سیستم بسته‌های پستی استفاده شدند، هر دو جزو دسته الگوهای رفتاری (Behavioral Patterns) هستند.

---
### الگوهای رفتاری

این دسته از الگوها به نحوه تعامل و تخصیص مسئولیت‌ها بین اشیاء می‌پردازند. آن‌ها الگوهای ارتباطی رایج بین اشیاء را شناسایی و پیاده‌سازی می‌کنند و انعطاف‌پذیری را در نحوه همکاری اشیاء با یکدیگر افزایش می‌دهند.

الگوی Strategy (استراتژی): یک الگوی رفتاری است زیرا به شما امکان می‌دهد خانواده‌ای از الگوریتم‌ها را تعریف کرده، هر کدام را کپسوله کنید و آن‌ها را قابل تعویض نمایید. این الگو بر نحوه انجام یک عمل (رفتار) توسط یک شیء (Context) تمرکز دارد و اجازه می‌دهد این رفتار در زمان اجرا تغییر کند.
الگوی State (وضعیت): نیز یک الگوی رفتاری است زیرا به یک شیء اجازه می‌دهد رفتار خود را زمانی که وضعیت داخلی‌اش تغییر می‌کند، تغییر دهد. این الگو چگونگی رفتار یک شیء را بر اساس وضعیت فعلی‌اش مدیریت می‌کند.


۳- با توجه به این که در هر اجرا محصرا یک بسته داریم و هیچ بسته‌ی دیگری بجز آن نداریم، کدام الگوی طراحی را برای ایحاد آن مناسب می‌دانید؟ ضمن بیان علت انتخاب خود، نحوه تحقق الگو را به طور کامل توضیح دهید.



برای ایجاد و مدیریت تنها یک نمونه از بسته پستی در طول اجرای برنامه، الگوی طراحی Singleton (یگانه) مناسب‌ترین گزینه است.

---
در ادامه به توضیح این قشیه می‌پردازیم که چرا سینگلتون بهترین گزینه است:

تضمین یگانگی: این الگو اطمینان می‌دهد که تنها یک شیء (instance) از کلاس `Package` ساخته می‌شود، که دقیقاً با شرط "محصراً یک بسته داریم" هماهنگ است.
دسترسی سراسری: یک نقطه دسترسی عمومی و کنترل‌شده به این نمونه واحد فراهم می‌کند.

---
### نحوه پیاده‌سازی و تحقق

1.  سازنده (Constructor) خصوصی:
    * سازنده کلاس `Package` به صورت `private` تعریف می‌شود (مثلاً `private Package(double weight)`). این کار از ایجاد نمونه با `new` از خارج کلاس جلوگیری می‌کند.

2.  متغیر استاتیک نمونه:
    * یک متغیر استاتیک خصوصی در کلاس `Package` برای نگهداری نمونه واحد تعریف می‌شود: `private static Package instance;`.

3.  متد `getInstance` عمومی و استاتیک:
     یک متد `public static Package getInstance(double weight)` ایجاد می‌شود.
    منطق داخلی:
        * اگر `instance` هنوز `null` باشد (یعنی اولین فراخوانی)، یک نمونه جدید `Package` با وزن داده شده ایجاد و در `instance` ذخیره می‌شود.
        * در غیر این صورت (فراخوانی‌های بعدی)، همان `instance` قبلی برگردانده می‌شود. وزن ورودی در این حالت معمولاً نادیده گرفته می‌شود یا برای اعتبار سنجی استفاده می‌شود (چون بسته قبلاً با یک وزن مشخص ایجاد شده).
    * برای جلوگیری از مشکلات در محیط‌های چندنخی، این متد می‌تواند `synchronized` تعریف شود.

4.  فراخوانی از `Main`:
    * در کلاس `Main`، به جای `postalPackage = new Package(weight);` از `postalPackage = Package.getInstance(weight);` برای دریافت یا ایجاد نمونه بسته استفاده می‌شود.

5.  پیام وضعیت اولیه:
    * پیام اولیه "in-transit" که قبلاً هنگام ساخت شیء چاپ می‌شد، اکنون باید پس از اولین فراخوانی `getInstance` و ایجاد شیء (مثلاً با فراخوانی یک متد کمکی مانند `initializeStateMessage()` روی نمونه برگردانده شده یا مستقیماً درون `getInstance` پس از ایجاد) نمایش داده شود.

---
با این روش، کلاس `Package` کنترل کاملی بر تعداد نمونه‌های خود (که فقط یکی است) خواهد داشت و سایر بخش‌های برنامه از طریق متد `getInstance` به آن دسترسی پیدا می‌کنند. سایر عملکردها و الگوهای (Strategy و State) که قبلاً برای کلاس `Package` تعریف شده بودند، درون همین نمونه Singleton مدیریت می‌شوند.



۴- تحقق و یا عدم تحقق هر کدام از اصول SOLID را در خصوص الگوی طراحی Singleton بیان کنید (هرکدام حداکثر در سه خط).

اصل تک مسئولیتی (Single Responsibility Principle - SRP): عدم تحقق
کلاس Singleton علاوه بر مسئولیت اصلی خود (که بسته به کاربرد متفاوت است)، مسئولیت کنترل ایجاد و دسترسی به تنها نمونه خود را نیز بر عهده دارد. این دو مسئولیت مجزا هستند و طبق اصل SRP، باید در کلاس‌های جداگانه‌ای قرار گیرند.

اصل باز/بسته (Open/Closed Principle - OCP): عدم تحقق
کلاس‌های Singleton معمولاً برای توسعه باز نیستند، زیرا سازنده آن‌ها خصوصی است و امکان ارث‌بری و گسترش رفتار آن‌ها به سادگی وجود ندارد. برای تغییر رفتار، اغلب نیاز به تغییر خود کلاس Singleton است که ناقض اصل بسته بودن برای تغییر است.

اصل جایگزینی لیسکوف (Liskov Substitution Principle - LSP): عدم تحقق (در اکثر پیاده‌سازی‌های رایج)
از آنجایی که سازنده Singleton خصوصی است و امکان ارث‌بری مستقیم و ایجاد زیرکلاس‌های قابل جایگزین که رفتار اصلی را حفظ کنند وجود ندارد، این اصل معمولاً نقض می‌شود. اگرچه می‌توان Singleton را با استفاده از اینترفیس پیاده‌سازی کرد تا حدی LSP رعایت شود، اما ذات کنترل نمونه‌سازی توسط خود کلاس، مشکل‌ساز است.

اصل جداسازی اینترفیس (Interface Segregation Principle - ISP): می‌تواند تحقق یابد
الگوی Singleton به خودی خود مستقیماً با این اصل در تضاد نیست. اگر Singleton یک اینترفیس "چاق" (fat interface) را پیاده‌سازی کند، آنگاه ISP نقض می‌شود. اما اگر اینترفیسی که Singleton پیاده‌سازی می‌کند (در صورت وجود) کوچک و متمرکز باشد، این اصل رعایت می‌شود.

اصل وارونگی وابستگی (Dependency Inversion Principle - DIP): عدم تحقق
کلاس‌هایی که از Singleton استفاده می‌کنند، مستقیماً به کلاس بتنی (concrete) آن وابسته می‌شوند، نه به یک انتزاع (abstraction). این وابستگی مستقیم به یک پیاده‌سازی خاص، انعطاف‌پذیری را کاهش داده و تست‌پذیری را دشوار می‌کند و بنابراین اصل وارونگی وابستگی را نقض می‌کند.
